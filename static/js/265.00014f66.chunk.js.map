{"version":3,"file":"static/js/265.00014f66.chunk.js","mappings":"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","sources":["types.ts","utils.ts","game.ts","worker.ts","workerUtils.ts"],"sourcesContent":["export type Suit = 'C' | 'D' | 'H' | 'S';\nexport type Rank =\n  | '2'\n  | '3'\n  | '4'\n  | '5'\n  | '6'\n  | '7'\n  | '8'\n  | '9'\n  | 'T'\n  | 'J'\n  | 'Q'\n  | 'K'\n  | 'A';\nexport type Card = `${Rank}${Suit}`;\n\nexport enum HandRank {\n  highCard = 0,\n  onePair = 1,\n  twoPair = 2,\n  threeOfAKind = 3,\n  straight = 4,\n  flush = 5,\n  fullHouse = 6,\n  fourOfAKind = 7,\n  straightFlush = 8,\n  royalFlush = 9\n}\n\ntype Without<T, U> = {\n  [P in Exclude<keyof T, keyof U>]?: undefined;\n};\n\nexport type Either<T, U> = T | U extends object\n  ? (Without<T, U> & U) | (Without<U, T> & T)\n  : T | U;\n\nexport interface SimulationParams {\n  myHand: Card[];\n  numPlayers: number;\n  communityCards: Card[];\n  potSize: number;\n  amountToCall: number;\n  simulationIterations: number;\n  progressInterval: number;\n}\n\n// export type SimulationWorker = WorkerInit<\n//   { simulate: SimulationParams },\n//   { simulationProgress: { pct: number; winProbability: number } }\n// >;\n","/**\n * Get all combinations of a subset of size groupSize from an array of items.\n * @param items - The array of items to generate combinations from.\n * @param groupSize - The size of each subset.\n * @returns An array of combinations, where each combination is an array of items.\n */\nexport function getCombinations<T>(items: T[], groupSize: number): T[][] {\n  const results: T[][] = [];\n\n  function combine(start: number, combination: T[]): void {\n    if (combination.length === groupSize) {\n      results.push([...combination]);\n      return;\n    }\n\n    for (let i = start; i < items.length; i++) {\n      combination.push(items[i]);\n      combine(i + 1, combination);\n      combination.pop();\n    }\n  }\n\n  combine(0, []);\n  return results;\n}\n\n/**\n * Shuffles the given array in-place, and returns the array.\n */\nexport function shuffle<T>(array: T[]) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n","import { Card, HandRank, Rank, Suit } from './types';\nimport { getCombinations, shuffle } from './utils';\n\nexport class Deck {\n  static suits: Suit[] = ['C', 'D', 'H', 'S'];\n  static ranks: Rank[] = [\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    'T',\n    'J',\n    'Q',\n    'K',\n    'A'\n  ];\n\n  static getRank = (card: Card) => card[0] as Rank;\n  static getSuit = (card: Card) => card[1] as Suit;\n  static getScore = (() => {\n    const scoreTable: Record<Rank, number> = {} as any;\n    Deck.ranks.forEach((rank, idx) => {\n      scoreTable[rank] = idx + 2;\n    });\n    return (card: Card) => scoreTable[Deck.getRank(card)];\n  })();\n\n  static getCards = (): Card[] =>\n    Deck.suits\n      .map(suit => Deck.ranks.map(rank => `${rank}${suit}` as Card))\n      .flat();\n\n  static getShuffledCards = () => shuffle(this.getCards());\n\n  reset = () => (this.cards = Deck.getShuffledCards());\n\n  private cards = Deck.getShuffledCards();\n\n  clone = () => {\n    const newDeck = new Deck();\n    newDeck.cards = [...this.cards];\n    return newDeck;\n  };\n\n  removeCard = (card: Card) => {\n    const index = this.cards.indexOf(card);\n    if (index > -1) this.cards.splice(index, 1);\n  };\n\n  private drawCard = () => {\n    const index = Math.floor(Math.random() * this.cards.length);\n    const card = this.cards[index];\n    this.cards.splice(index, 1);\n    return card;\n  };\n\n  draw = (nCards = 1) => Array.from({ length: nCards }, () => this.drawCard());\n\n  shuffle = () => {\n    shuffle(this.cards);\n    return this;\n  };\n}\n\nexport abstract class Hand {\n  static rankToString = (rank: HandRank) => {\n    switch (rank) {\n      case HandRank.royalFlush:\n        return 'Royal Flush';\n      case HandRank.straightFlush:\n        return 'Straight Flush';\n      case HandRank.fourOfAKind:\n        return 'Four of a Kind';\n      case HandRank.fullHouse:\n        return 'Full House';\n      case HandRank.flush:\n        return 'Flush';\n      case HandRank.straight:\n        return 'Straight';\n      case HandRank.threeOfAKind:\n        return 'Three of a Kind';\n      case HandRank.twoPair:\n        return 'Two pair';\n      case HandRank.onePair:\n        return 'One pair';\n      default:\n        return 'High card';\n    }\n  };\n\n  static rank = (hand: Card[]): [HandRank, number[]] => {\n    if (hand.some(test => test === undefined))\n      throw new Error('Missing cards in hand');\n    const handRanks = hand.map(Deck.getScore).sort((a, b) => b - a);\n    const uniqueSuits = new Set(hand.map(Deck.getSuit)).size;\n\n    // Flush\n    if (uniqueSuits === 1) {\n      if (handRanks.join('') === '1413121110')\n        return [HandRank.royalFlush, handRanks];\n      if (handRanks[0] - handRanks[4] === 4)\n        return [HandRank.straightFlush, handRanks];\n      return [HandRank.flush, handRanks];\n    }\n\n    const handCounts = handRanks.reduce((acc: Record<number, number>, rank) => {\n      acc[rank] = (acc[rank] || 0) + 1;\n      return acc;\n    }, {});\n\n    const sortedRanks = Object.keys(handCounts)\n      .map(Number)\n      .sort((a, b) => {\n        const ca = handCounts[a];\n        const cb = handCounts[b];\n        if (ca === cb) return b - a;\n        return cb - ca;\n      });\n\n    // Four of a Kind\n    if (handCounts[sortedRanks[0]] === 4) {\n      return [HandRank.fourOfAKind, sortedRanks];\n    }\n\n    // Full House\n    if (handCounts[sortedRanks[0]] === 3 && handCounts[sortedRanks[1]] === 2) {\n      return [HandRank.fullHouse, sortedRanks];\n    }\n\n    // Straight\n    if (handRanks[0] - handRanks[4] === 4 && new Set(handRanks).size === 5) {\n      return [HandRank.straight, handRanks];\n    }\n\n    // Three of a Kind\n    if (handCounts[sortedRanks[0]] === 3) {\n      return [HandRank.threeOfAKind, sortedRanks];\n    }\n\n    // Two pair\n    if (handCounts[sortedRanks[0]] === 2 && handCounts[sortedRanks[1]] === 2) {\n      return [HandRank.twoPair, sortedRanks];\n    }\n\n    // One pair\n    if (handCounts[sortedRanks[0]] === 2) {\n      return [HandRank.onePair, sortedRanks];\n    }\n\n    // High Card\n    return [HandRank.highCard, sortedRanks];\n  };\n\n  static best = (cards: Card[]) => {\n    const combinations = getCombinations(cards, 5);\n    return combinations\n      .map(\n        combo => [...this.rank(combo), combo] as [HandRank, number[], Card[]]\n      )\n      .reduce((best, current) =>\n        current[0] > best[0] ||\n        (current[0] === best[0] &&\n          current[1].map(v => v.toString().padStart(2, '0')).join() >\n            best[1].map(v => v.toString().padStart(2, '0')).join())\n          ? current\n          : best\n      )!;\n  };\n\n  static compare = (\n    hand1: [HandRank, number[], Card[]],\n    hand2: [HandRank, number[], Card[]]\n  ) => {\n    const handOneRank = hand1[0];\n    const handTwoRank = hand2[0];\n    if (handOneRank !== handTwoRank) return handOneRank - handTwoRank;\n\n    for (let i = 0; i < hand1[1].length; i++) {\n      const handOneCardRank = hand1[1][i];\n      const handTwoCardRank = hand2[1][i];\n      if (handOneCardRank !== handTwoCardRank)\n        return handOneCardRank - handTwoCardRank;\n    }\n\n    return 0;\n  };\n}\n\nexport class Game {\n  private deck = new Deck();\n\n  public communityCards: Card[] = [];\n  public potSize = 0;\n  public amountToCall = 0;\n\n  public maxRaiseAmount = 1000;\n  public foldProbability = 0.2; // Probability that a player will fold when faced with a raise\n\n  private calculatedWinProbability?: number;\n\n  constructor(\n    public myHand: Card[],\n    public numPlayers: number,\n    private simulationSettings:\n      | { iterations: number; milliseconds?: undefined }\n      | { iterations?: undefined; milliseconds: number } = {\n      iterations: 10e3\n    }\n  ) {\n    myHand.forEach(card => this.deck.removeCard(card));\n    console.log('New game:', this);\n  }\n\n  resetCalculations = () => {\n    this.calculatedWinProbability = undefined;\n  };\n\n  setPotSize = (potSize: number) => (this.potSize = potSize);\n\n  setAmountToCall = (amountToCall: number) =>\n    (this.amountToCall = amountToCall);\n\n  setNumPlayers = (numPlayers: number) => {\n    this.resetCalculations();\n    return (this.numPlayers = numPlayers);\n  };\n\n  addCommunityCard = (card: Card) => {\n    this.resetCalculations();\n    this.deck.removeCard(card);\n    this.communityCards.push(card);\n  };\n\n  drawCommunityCards = (nCards = 1) => {\n    this.resetCalculations();\n    this.communityCards.push(...this.deck.draw(nCards));\n  };\n\n  simulateOnce = () => {\n    const deckCopy = this.deck.clone().shuffle();\n\n    const community = [\n      ...this.communityCards,\n      ...deckCopy.draw(5 - this.communityCards.length)\n    ];\n\n    const myBestHand = Hand.best([...this.myHand, ...community]);\n\n    const opponents = Array.from({ length: this.numPlayers }, () =>\n      deckCopy.draw(2)\n    );\n\n    const didWin = opponents.every(opHand => {\n      const opponentBestHand = Hand.best([...opHand, ...community]);\n      return Hand.compare(myBestHand, opponentBestHand) >= 0;\n    });\n\n    return didWin;\n  };\n\n  simulate = () => {\n    let wins = 0;\n    let simulationsCount = 0;\n\n    const t1 = Date.now();\n\n    if (this.simulationSettings.iterations) {\n      simulationsCount = this.simulationSettings.iterations;\n      for (let i = 0; i < simulationsCount; i++)\n        if (this.simulateOnce()) wins += 1;\n    } else {\n      const ms = this.simulationSettings.milliseconds!;\n      const expiration = t1 + ms;\n      while (Date.now() < expiration) {\n        simulationsCount += 1;\n        if (this.simulateOnce()) wins += 1;\n      }\n    }\n\n    const t2 = Date.now();\n\n    console.log(\n      `Simulations: ${simulationsCount} (${\n        (1000 * simulationsCount) / (t2 - t1)\n      }/s)`\n    );\n\n    return wins / simulationsCount;\n  };\n\n  get winProbability() {\n    if (this.calculatedWinProbability === undefined)\n      return (this.calculatedWinProbability = this.simulate());\n    return this.calculatedWinProbability;\n  }\n\n  getExpectedReturnOnCall = () => {\n    return (\n      this.winProbability * (this.potSize + this.amountToCall) -\n      this.amountToCall\n    );\n  };\n\n  getIdealRaiseAmount = () => {\n    const winProbability = this.winProbability;\n    let bestRaiseAmount = 0;\n    let maxExpectedReturn = this.getExpectedReturnOnCall();\n\n    for (\n      let raiseAmount = this.amountToCall;\n      raiseAmount <= this.maxRaiseAmount;\n      raiseAmount++\n    ) {\n      let expectedReturn = 0;\n      for (let k = 0; k <= this.numPlayers; k++) {\n        const combinationProbability =\n          Math.pow(1 - this.foldProbability, k) *\n          Math.pow(this.foldProbability, this.numPlayers - k);\n        const potAfterRaise = this.potSize + raiseAmount * (k + 1);\n        const costToRaise = raiseAmount;\n        const foldAdjustedWinProbability =\n          winProbability * Math.pow(this.foldProbability, this.numPlayers - k);\n        expectedReturn +=\n          combinationProbability *\n          (foldAdjustedWinProbability * potAfterRaise - costToRaise);\n      }\n\n      if (expectedReturn > maxExpectedReturn) {\n        maxExpectedReturn = expectedReturn;\n        bestRaiseAmount = raiseAmount;\n      }\n    }\n\n    return bestRaiseAmount;\n  };\n\n  // Decide whether to call, raise, or fold\n  decideAction = (): { action: 'call' | 'raise' | 'fold'; amount: number } => {\n    const expectedReturnOnCall = this.getExpectedReturnOnCall();\n    const idealRaiseAmount = this.getIdealRaiseAmount();\n    const expectedReturnOnRaise =\n      this.getExpectedReturnOnCall() +\n      (idealRaiseAmount > 0 ? idealRaiseAmount : 0);\n\n    if (\n      expectedReturnOnCall > 0 &&\n      expectedReturnOnCall >= expectedReturnOnRaise\n    ) {\n      return { action: 'call', amount: this.amountToCall };\n    } else if (expectedReturnOnRaise > expectedReturnOnCall) {\n      return { action: 'raise', amount: idealRaiseAmount };\n    } else {\n      return { action: 'fold', amount: 0 };\n    }\n  };\n}\n","import { Game } from './game';\nimport { SimulationParams } from './types';\nimport { createMessageSender } from './workerUtils';\n\nconst sendMessage = createMessageSender<{\n  progress: { pct: number; winProbability: number };\n}>();\n\nself.addEventListener(\n  'message',\n  (\n    event: MessageEvent<{\n      type: 'simulation';\n      data: SimulationParams;\n    }>\n  ) => {\n    const {\n      myHand,\n      numPlayers,\n      communityCards,\n      potSize,\n      amountToCall,\n      simulationIterations,\n      progressInterval\n    } = event.data.data;\n\n    const t1 = Date.now();\n\n    const game = new Game(myHand, numPlayers, {\n      iterations: simulationIterations\n    });\n    game.setPotSize(potSize);\n    game.setAmountToCall(amountToCall);\n    communityCards.forEach(card => game.addCommunityCard(card));\n\n    let wins = 0;\n    for (let i = 0; i < simulationIterations; i++) {\n      if (game.simulateOnce()) wins += 1;\n      if (i % progressInterval === 0) {\n        sendMessage('progress', {\n          pct: (i / simulationIterations) * 100,\n          winProbability: wins / (i + 1)\n        });\n      }\n    }\n    const winProbability = wins / simulationIterations;\n    sendMessage('progress', { pct: 100, winProbability });\n\n    const t2 = Date.now();\n    console.log(\n      `${Math.round((1000 * simulationIterations) / (t2 - t1))} sim/sec`\n    );\n\n    sendMessage.terminate();\n  }\n);\n","export function createWorker<\n  I extends { [type: string]: any },\n  O extends { [type: string]: any }\n>(\n  worker: Worker,\n  messageHandlers: { [type in keyof O]: (data: O[type]) => void },\n  onTerminate?: () => void\n) {\n  const handleTerminate = (() => {\n    let didTerminate = false;\n    return () => {\n      if (!didTerminate) {\n        didTerminate = true;\n        worker.terminate();\n        onTerminate?.();\n      }\n    };\n  })();\n\n  worker.onmessage = (\n    message: MessageEvent<\n      { [key in keyof O]: { type: key; data: O[key] } }[keyof O] | 'TERMINATE'\n    >\n  ) => {\n    if (message.data === 'TERMINATE') {\n      handleTerminate();\n    } else {\n      messageHandlers[message.data.type](message.data.data);\n    }\n  };\n\n  return {\n    post: <K extends keyof I>(type: K, data: I[K]) =>\n      worker.postMessage({ type, data }),\n    terminate: () => {\n      handleTerminate();\n    }\n  };\n}\n\nexport function createMessageSender<T extends { [type: string]: any }>() {\n  function sendMessage<K extends keyof T>(type: K, data: T[K]) {\n    self.postMessage({ type, data });\n  }\n  sendMessage.terminate = () => {\n    self.postMessage('TERMINATE');\n  };\n  return sendMessage;\n}\n"],"names":["HandRank","shuffle","array","i","length","j","Math","floor","random","Deck","constructor","_this","reset","this","cards","getShuffledCards","clone","newDeck","removeCard","card","index","indexOf","splice","drawCard","draw","nCards","arguments","undefined","Array","from","_Deck","suits","ranks","getRank","getSuit","getScore","scoreTable","forEach","rank","idx","getCards","map","suit","concat","flat","Hand","_Hand","rankToString","royalFlush","straightFlush","fourOfAKind","fullHouse","flush","straight","threeOfAKind","twoPair","onePair","hand","some","test","Error","handRanks","sort","a","b","Set","size","join","handCounts","reduce","acc","sortedRanks","Object","keys","Number","ca","cb","highCard","best","items","groupSize","results","combine","start","combination","push","pop","getCombinations","combo","current","v","toString","padStart","compare","hand1","hand2","handOneRank","handTwoRank","handOneCardRank","handTwoCardRank","Game","myHand","numPlayers","_this2","simulationSettings","iterations","deck","communityCards","potSize","amountToCall","maxRaiseAmount","foldProbability","calculatedWinProbability","resetCalculations","setPotSize","setAmountToCall","setNumPlayers","addCommunityCard","drawCommunityCards","simulateOnce","deckCopy","community","myBestHand","every","opHand","opponentBestHand","simulate","wins","simulationsCount","t1","Date","now","expiration","milliseconds","t2","console","log","getExpectedReturnOnCall","winProbability","getIdealRaiseAmount","bestRaiseAmount","maxExpectedReturn","raiseAmount","expectedReturn","k","combinationProbability","pow","potAfterRaise","costToRaise","decideAction","expectedReturnOnCall","idealRaiseAmount","expectedReturnOnRaise","action","amount","sendMessage","type","data","self","postMessage","terminate","createMessageSender","addEventListener","event","simulationIterations","progressInterval","game","pct","round"],"sourceRoot":""}