(()=>{"use strict";let t=function(t){return t[t.highCard=0]="highCard",t[t.onePair=1]="onePair",t[t.twoPair=2]="twoPair",t[t.threeOfAKind=3]="threeOfAKind",t[t.straight=4]="straight",t[t.flush=5]="flush",t[t.fullHouse=6]="fullHouse",t[t.fourOfAKind=7]="fourOfAKind",t[t.straightFlush=8]="straightFlush",t[t.royalFlush=9]="royalFlush",t}({});function s(t){for(let s=t.length-1;s>0;s--){const i=Math.floor(Math.random()*(s+1));[t[s],t[i]]=[t[i],t[s]]}return t}var i,e;class a{constructor(){var t=this;this.reset=()=>this.cards=a.getShuffledCards(),this.cards=a.getShuffledCards(),this.clone=()=>{const t=new a;return t.cards=[...this.cards],t},this.removeCard=t=>{const s=this.cards.indexOf(t);s>-1&&this.cards.splice(s,1)},this.drawCard=()=>{const t=Math.floor(Math.random()*this.cards.length),s=this.cards[t];return this.cards.splice(t,1),s},this.draw=function(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return Array.from({length:s},(()=>t.drawCard()))},this.shuffle=()=>(s(this.cards),this)}}i=a,a.suits=["C","D","H","S"],a.ranks=["2","3","4","5","6","7","8","9","T","J","Q","K","A"],a.getRank=t=>t[0],a.getSuit=t=>t[1],a.getScore=(()=>{const t={};return i.ranks.forEach(((s,i)=>{t[s]=i+2})),s=>t[i.getRank(s)]})(),a.getCards=()=>i.suits.map((t=>i.ranks.map((s=>"".concat(s).concat(t))))).flat(),a.getShuffledCards=()=>s(i.getCards());class n{}e=n,n.rank=s=>{if(s.some((t=>void 0===t)))throw new Error("Missing cards in hand");const i=s.map(a.getScore).sort(((t,s)=>s-t));if(1===new Set(s.map(a.getSuit)).size)return"1413121110"===i.join("")?[t.royalFlush,i]:i[0]-i[4]===4?[t.straightFlush,i]:[t.flush,i];const e=i.reduce(((t,s)=>(t[s]=(t[s]||0)+1,t)),{}),n=Object.keys(e).map(Number).sort(((t,s)=>{const i=e[t],a=e[s];return i===a?s-t:a-i}));return 4===e[n[0]]?[t.fourOfAKind,n]:3===e[n[0]]&&2===e[n[1]]?[t.fullHouse,n]:i[0]-i[4]===4&&5===new Set(i).size?[t.straight,i]:3===e[n[0]]?[t.threeOfAKind,n]:2===e[n[0]]&&2===e[n[1]]?[t.twoPair,n]:2===e[n[0]]?[t.onePair,n]:[t.highCard,n]},n.best=t=>function(t,s){const i=[];return function e(a,n){if(n.length!==s)for(let s=a;s<t.length;s++)n.push(t[s]),e(s+1,n),n.pop();else i.push([...n])}(0,[]),i}(t,5).map((t=>e.rank(t))).reduce(((t,s)=>s[0]>t[0]||s[0]===t[0]&&s[1].join()>t[1].join()?s:t)),n.compare=(t,s)=>{const i=t[0],e=s[0];if(i!==e)return i-e;for(let a=0;a<t[1].length;a++){const i=t[1][a],e=s[1][a];if(i!==e)return i-e}return 0};class o{constructor(t,s){var i=this;let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{iterations:1e4};this.myHand=t,this.numPlayers=s,this.simulationSettings=e,this.deck=new a,this.communityCards=[],this.potSize=0,this.amountToCall=0,this.maxRaiseAmount=1e3,this.foldProbability=.2,this.calculatedWinProbability=void 0,this.resetCalculations=()=>{this.calculatedWinProbability=void 0},this.setPotSize=t=>this.potSize=t,this.setAmountToCall=t=>this.amountToCall=t,this.setNumPlayers=t=>(this.resetCalculations(),this.numPlayers=t),this.addCommunityCard=t=>{this.resetCalculations(),this.deck.removeCard(t),this.communityCards.push(t)},this.drawCommunityCards=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;i.resetCalculations(),i.communityCards.push(...i.deck.draw(t))},this.simulateOnce=()=>{const t=this.deck.clone().shuffle(),s=[...this.communityCards,...t.draw(5-this.communityCards.length)],i=n.best([...this.myHand,...s]);return Array.from({length:this.numPlayers},(()=>t.draw(2))).every((t=>{const e=n.best([...t,...s]);return n.compare(i,e)>=0}))},this.simulate=()=>{let t=0,s=0;const i=Date.now();if(this.simulationSettings.iterations){s=this.simulationSettings.iterations;for(let i=0;i<s;i++)this.simulateOnce()&&(t+=1)}else{const e=i+this.simulationSettings.milliseconds;for(;Date.now()<e;)s+=1,this.simulateOnce()&&(t+=1)}const e=Date.now();return console.log("Simulations: ".concat(s," (").concat(1e3*s/(e-i),"/s)")),t/s},this.getExpectedReturnOnCall=()=>this.winProbability*(this.potSize+this.amountToCall)-this.amountToCall,this.getIdealRaiseAmount=()=>{const t=this.winProbability;let s=0,i=this.getExpectedReturnOnCall();for(let e=this.amountToCall;e<=this.maxRaiseAmount;e++){let a=0;for(let s=0;s<=this.numPlayers;s++){const i=Math.pow(1-this.foldProbability,s)*Math.pow(this.foldProbability,this.numPlayers-s),n=this.potSize+e*(s+1),o=e;a+=i*(t*Math.pow(this.foldProbability,this.numPlayers-s)*n-o)}a>i&&(i=a,s=e)}return s},this.decideAction=()=>{const t=this.getExpectedReturnOnCall(),s=this.getIdealRaiseAmount(),i=this.getExpectedReturnOnCall()+(s>0?s:0);return t>0&&t>=i?{action:"call",amount:this.amountToCall}:i>t?{action:"raise",amount:s}:{action:"fold",amount:0}},t.forEach((t=>this.deck.removeCard(t))),console.log("New game:",this)}get winProbability(){return void 0===this.calculatedWinProbability?this.calculatedWinProbability=this.simulate():this.calculatedWinProbability}}const r=function(){function t(t,s){self.postMessage({type:t,data:s})}return t.terminate=()=>{self.postMessage("TERMINATE")},t}();self.addEventListener("message",(t=>{const{myHand:s,numPlayers:i,communityCards:e,potSize:a,amountToCall:n,simulationIterations:l,progressInterval:h}=t.data.data,u=Date.now(),c=new o(s,i,{iterations:l});c.setPotSize(a),c.setAmountToCall(n),e.forEach((t=>c.addCommunityCard(t)));let d=0;for(let o=0;o<l;o++)c.simulateOnce()&&(d+=1),o%h===0&&r("progress",{pct:o/l*100,winProbability:d/(o+1)});r("progress",{pct:100,winProbability:d/l});const m=Date.now();console.log("".concat(Math.round(1e3*l/(m-u))," sim/sec")),r.terminate()}))})();
//# sourceMappingURL=265.87ed1e59.chunk.js.map