{"version":3,"file":"static/js/265.87ed1e59.chunk.js","mappings":"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","sources":["types.ts","utils.ts","game.ts","worker.ts","workerUtils.ts"],"sourcesContent":["export type Suit = 'C' | 'D' | 'H' | 'S';\nexport type Rank =\n  | '2'\n  | '3'\n  | '4'\n  | '5'\n  | '6'\n  | '7'\n  | '8'\n  | '9'\n  | 'T'\n  | 'J'\n  | 'Q'\n  | 'K'\n  | 'A';\nexport type Card = `${Rank}${Suit}`;\n\nexport enum HandRank {\n  highCard = 0,\n  onePair = 1,\n  twoPair = 2,\n  threeOfAKind = 3,\n  straight = 4,\n  flush = 5,\n  fullHouse = 6,\n  fourOfAKind = 7,\n  straightFlush = 8,\n  royalFlush = 9\n}\n\ntype Without<T, U> = {\n  [P in Exclude<keyof T, keyof U>]?: undefined;\n};\n\nexport type Either<T, U> = T | U extends object\n  ? (Without<T, U> & U) | (Without<U, T> & T)\n  : T | U;\n\nexport interface SimulationParams {\n  myHand: Card[];\n  numPlayers: number;\n  communityCards: Card[];\n  potSize: number;\n  amountToCall: number;\n  simulationIterations: number;\n  progressInterval: number;\n}\n\n// export type SimulationWorker = WorkerInit<\n//   { simulate: SimulationParams },\n//   { simulationProgress: { pct: number; winProbability: number } }\n// >;\n","/**\n * Get all combinations of a subset of size groupSize from an array of items.\n * @param items - The array of items to generate combinations from.\n * @param groupSize - The size of each subset.\n * @returns An array of combinations, where each combination is an array of items.\n */\nexport function getCombinations<T>(items: T[], groupSize: number): T[][] {\n  const results: T[][] = [];\n\n  function combine(start: number, combination: T[]): void {\n    if (combination.length === groupSize) {\n      results.push([...combination]);\n      return;\n    }\n\n    for (let i = start; i < items.length; i++) {\n      combination.push(items[i]);\n      combine(i + 1, combination);\n      combination.pop();\n    }\n  }\n\n  combine(0, []);\n  return results;\n}\n\n/**\n * Shuffles the given array in-place, and returns the array.\n */\nexport function shuffle<T>(array: T[]) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n","import { Card, HandRank, Rank, Suit } from './types';\nimport { getCombinations, shuffle } from './utils';\n\nclass Deck {\n  static suits: Suit[] = ['C', 'D', 'H', 'S'];\n  static ranks: Rank[] = [\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    'T',\n    'J',\n    'Q',\n    'K',\n    'A'\n  ];\n\n  static getRank = (card: Card) => card[0] as Rank;\n  static getSuit = (card: Card) => card[1] as Suit;\n  static getScore = (() => {\n    const scoreTable: Record<Rank, number> = {} as any;\n    Deck.ranks.forEach((rank, idx) => {\n      scoreTable[rank] = idx + 2;\n    });\n    return (card: Card) => scoreTable[Deck.getRank(card)];\n  })();\n\n  static getCards = (): Card[] =>\n    Deck.suits\n      .map(suit => Deck.ranks.map(rank => `${rank}${suit}` as Card))\n      .flat();\n\n  static getShuffledCards = () => shuffle(this.getCards());\n\n  reset = () => (this.cards = Deck.getShuffledCards());\n\n  private cards = Deck.getShuffledCards();\n\n  clone = () => {\n    const newDeck = new Deck();\n    newDeck.cards = [...this.cards];\n    return newDeck;\n  };\n\n  removeCard = (card: Card) => {\n    const index = this.cards.indexOf(card);\n    if (index > -1) this.cards.splice(index, 1);\n  };\n\n  private drawCard = () => {\n    const index = Math.floor(Math.random() * this.cards.length);\n    const card = this.cards[index];\n    this.cards.splice(index, 1);\n    return card;\n  };\n\n  draw = (nCards = 1) => Array.from({ length: nCards }, () => this.drawCard());\n\n  shuffle = () => {\n    shuffle(this.cards);\n    return this;\n  };\n}\n\nabstract class Hand {\n  static rank = (hand: Card[]): [HandRank, number[]] => {\n    if (hand.some(test => test === undefined))\n      throw new Error('Missing cards in hand');\n    const handRanks = hand.map(Deck.getScore).sort((a, b) => b - a);\n    const uniqueSuits = new Set(hand.map(Deck.getSuit)).size;\n\n    // Flush\n    if (uniqueSuits === 1) {\n      if (handRanks.join('') === '1413121110')\n        return [HandRank.royalFlush, handRanks];\n      if (handRanks[0] - handRanks[4] === 4)\n        return [HandRank.straightFlush, handRanks];\n      return [HandRank.flush, handRanks];\n    }\n\n    const handCounts = handRanks.reduce((acc: Record<number, number>, rank) => {\n      acc[rank] = (acc[rank] || 0) + 1;\n      return acc;\n    }, {});\n\n    const sortedRanks = Object.keys(handCounts)\n      .map(Number)\n      .sort((a, b) => {\n        const ca = handCounts[a];\n        const cb = handCounts[b];\n        if (ca === cb) return b - a;\n        return cb - ca;\n      });\n\n    // Four of a Kind\n    if (handCounts[sortedRanks[0]] === 4) {\n      return [HandRank.fourOfAKind, sortedRanks];\n    }\n\n    // Full House\n    if (handCounts[sortedRanks[0]] === 3 && handCounts[sortedRanks[1]] === 2) {\n      return [HandRank.fullHouse, sortedRanks];\n    }\n\n    // Straight\n    if (handRanks[0] - handRanks[4] === 4 && new Set(handRanks).size === 5) {\n      return [HandRank.straight, handRanks];\n    }\n\n    // Three of a Kind\n    if (handCounts[sortedRanks[0]] === 3) {\n      return [HandRank.threeOfAKind, sortedRanks];\n    }\n\n    // Two pair\n    if (handCounts[sortedRanks[0]] === 2 && handCounts[sortedRanks[1]] === 2) {\n      return [HandRank.twoPair, sortedRanks];\n    }\n\n    // One pair\n    if (handCounts[sortedRanks[0]] === 2) {\n      return [HandRank.onePair, sortedRanks];\n    }\n\n    // High Card\n    return [HandRank.highCard, sortedRanks];\n  };\n\n  static best = (cards: Card[]) => {\n    const combinations = getCombinations(cards, 5);\n    return combinations\n      .map(combo => this.rank(combo))\n      .reduce((best, current) =>\n        current[0] > best[0] ||\n        (current[0] === best[0] && current[1].join() > best[1].join())\n          ? current\n          : best\n      );\n  };\n\n  static compare = (\n    hand1: [HandRank, number[]],\n    hand2: [HandRank, number[]]\n  ) => {\n    const handOneRank = hand1[0];\n    const handTwoRank = hand2[0];\n    if (handOneRank !== handTwoRank) return handOneRank - handTwoRank;\n\n    for (let i = 0; i < hand1[1].length; i++) {\n      const handOneCardRank = hand1[1][i];\n      const handTwoCardRank = hand2[1][i];\n      if (handOneCardRank !== handTwoCardRank)\n        return handOneCardRank - handTwoCardRank;\n    }\n\n    return 0;\n  };\n}\n\nexport class Game {\n  private deck = new Deck();\n\n  public communityCards: Card[] = [];\n  public potSize = 0;\n  public amountToCall = 0;\n\n  public maxRaiseAmount = 1000;\n  public foldProbability = 0.2; // Probability that a player will fold when faced with a raise\n\n  private calculatedWinProbability?: number;\n\n  constructor(\n    public myHand: Card[],\n    public numPlayers: number,\n    private simulationSettings:\n      | { iterations: number; milliseconds?: undefined }\n      | { iterations?: undefined; milliseconds: number } = {\n      iterations: 10e3\n    }\n  ) {\n    myHand.forEach(card => this.deck.removeCard(card));\n    console.log('New game:', this);\n  }\n\n  resetCalculations = () => {\n    this.calculatedWinProbability = undefined;\n  };\n\n  setPotSize = (potSize: number) => (this.potSize = potSize);\n\n  setAmountToCall = (amountToCall: number) =>\n    (this.amountToCall = amountToCall);\n\n  setNumPlayers = (numPlayers: number) => {\n    this.resetCalculations();\n    return (this.numPlayers = numPlayers);\n  };\n\n  addCommunityCard = (card: Card) => {\n    this.resetCalculations();\n    this.deck.removeCard(card);\n    this.communityCards.push(card);\n  };\n\n  drawCommunityCards = (nCards = 1) => {\n    this.resetCalculations();\n    this.communityCards.push(...this.deck.draw(nCards));\n  };\n\n  simulateOnce = () => {\n    const deckCopy = this.deck.clone().shuffle();\n\n    const community = [\n      ...this.communityCards,\n      ...deckCopy.draw(5 - this.communityCards.length)\n    ];\n\n    const myBestHand = Hand.best([...this.myHand, ...community]);\n\n    const opponents = Array.from({ length: this.numPlayers }, () =>\n      deckCopy.draw(2)\n    );\n\n    const didWin = opponents.every(opHand => {\n      const opponentBestHand = Hand.best([...opHand, ...community]);\n      return Hand.compare(myBestHand, opponentBestHand) >= 0;\n    });\n\n    return didWin;\n  };\n\n  simulate = () => {\n    let wins = 0;\n    let simulationsCount = 0;\n\n    const t1 = Date.now();\n\n    if (this.simulationSettings.iterations) {\n      simulationsCount = this.simulationSettings.iterations;\n      for (let i = 0; i < simulationsCount; i++)\n        if (this.simulateOnce()) wins += 1;\n    } else {\n      const ms = this.simulationSettings.milliseconds!;\n      const expiration = t1 + ms;\n      while (Date.now() < expiration) {\n        simulationsCount += 1;\n        if (this.simulateOnce()) wins += 1;\n      }\n    }\n\n    const t2 = Date.now();\n\n    console.log(\n      `Simulations: ${simulationsCount} (${\n        (1000 * simulationsCount) / (t2 - t1)\n      }/s)`\n    );\n\n    return wins / simulationsCount;\n  };\n\n  get winProbability() {\n    if (this.calculatedWinProbability === undefined)\n      return (this.calculatedWinProbability = this.simulate());\n    return this.calculatedWinProbability;\n  }\n\n  getExpectedReturnOnCall = () => {\n    return (\n      this.winProbability * (this.potSize + this.amountToCall) -\n      this.amountToCall\n    );\n  };\n\n  getIdealRaiseAmount = () => {\n    const winProbability = this.winProbability;\n    let bestRaiseAmount = 0;\n    let maxExpectedReturn = this.getExpectedReturnOnCall();\n\n    for (\n      let raiseAmount = this.amountToCall;\n      raiseAmount <= this.maxRaiseAmount;\n      raiseAmount++\n    ) {\n      let expectedReturn = 0;\n      for (let k = 0; k <= this.numPlayers; k++) {\n        const combinationProbability =\n          Math.pow(1 - this.foldProbability, k) *\n          Math.pow(this.foldProbability, this.numPlayers - k);\n        const potAfterRaise = this.potSize + raiseAmount * (k + 1);\n        const costToRaise = raiseAmount;\n        const foldAdjustedWinProbability =\n          winProbability * Math.pow(this.foldProbability, this.numPlayers - k);\n        expectedReturn +=\n          combinationProbability *\n          (foldAdjustedWinProbability * potAfterRaise - costToRaise);\n      }\n\n      if (expectedReturn > maxExpectedReturn) {\n        maxExpectedReturn = expectedReturn;\n        bestRaiseAmount = raiseAmount;\n      }\n    }\n\n    return bestRaiseAmount;\n  };\n\n  // Decide whether to call, raise, or fold\n  decideAction = (): { action: 'call' | 'raise' | 'fold'; amount: number } => {\n    const expectedReturnOnCall = this.getExpectedReturnOnCall();\n    const idealRaiseAmount = this.getIdealRaiseAmount();\n    const expectedReturnOnRaise =\n      this.getExpectedReturnOnCall() +\n      (idealRaiseAmount > 0 ? idealRaiseAmount : 0);\n\n    if (\n      expectedReturnOnCall > 0 &&\n      expectedReturnOnCall >= expectedReturnOnRaise\n    ) {\n      return { action: 'call', amount: this.amountToCall };\n    } else if (expectedReturnOnRaise > expectedReturnOnCall) {\n      return { action: 'raise', amount: idealRaiseAmount };\n    } else {\n      return { action: 'fold', amount: 0 };\n    }\n  };\n}\n","import { Game } from './game';\nimport { SimulationParams } from './types';\nimport { createMessageSender } from './workerUtils';\n\nconst sendMessage = createMessageSender<{\n  progress: { pct: number; winProbability: number };\n}>();\n\nself.addEventListener(\n  'message',\n  (\n    event: MessageEvent<{\n      type: 'simulation';\n      data: SimulationParams;\n    }>\n  ) => {\n    const {\n      myHand,\n      numPlayers,\n      communityCards,\n      potSize,\n      amountToCall,\n      simulationIterations,\n      progressInterval\n    } = event.data.data;\n\n    const t1 = Date.now();\n\n    const game = new Game(myHand, numPlayers, {\n      iterations: simulationIterations\n    });\n    game.setPotSize(potSize);\n    game.setAmountToCall(amountToCall);\n    communityCards.forEach(card => game.addCommunityCard(card));\n\n    let wins = 0;\n    for (let i = 0; i < simulationIterations; i++) {\n      if (game.simulateOnce()) wins += 1;\n      if (i % progressInterval === 0) {\n        sendMessage('progress', {\n          pct: (i / simulationIterations) * 100,\n          winProbability: wins / (i + 1)\n        });\n      }\n    }\n    const winProbability = wins / simulationIterations;\n    sendMessage('progress', { pct: 100, winProbability });\n\n    const t2 = Date.now();\n    console.log(\n      `${Math.round((1000 * simulationIterations) / (t2 - t1))} sim/sec`\n    );\n\n    sendMessage.terminate();\n  }\n);\n","export function createWorker<\n  I extends { [type: string]: any },\n  O extends { [type: string]: any }\n>(\n  worker: Worker,\n  messageHandlers: { [type in keyof O]: (data: O[type]) => void },\n  onTerminate?: () => void\n) {\n  const handleTerminate = (() => {\n    let didTerminate = false;\n    return () => {\n      if (!didTerminate) {\n        didTerminate = true;\n        worker.terminate();\n        onTerminate?.();\n      }\n    };\n  })();\n\n  worker.onmessage = (\n    message: MessageEvent<\n      { [key in keyof O]: { type: key; data: O[key] } }[keyof O] | 'TERMINATE'\n    >\n  ) => {\n    if (message.data === 'TERMINATE') {\n      handleTerminate();\n    } else {\n      messageHandlers[message.data.type](message.data.data);\n    }\n  };\n\n  return {\n    post: <K extends keyof I>(type: K, data: I[K]) =>\n      worker.postMessage({ type, data }),\n    terminate: () => {\n      handleTerminate();\n    }\n  };\n}\n\nexport function createMessageSender<T extends { [type: string]: any }>() {\n  function sendMessage<K extends keyof T>(type: K, data: T[K]) {\n    self.postMessage({ type, data });\n  }\n  sendMessage.terminate = () => {\n    self.postMessage('TERMINATE');\n  };\n  return sendMessage;\n}\n"],"names":["HandRank","shuffle","array","i","length","j","Math","floor","random","Deck","constructor","_this","reset","this","cards","getShuffledCards","clone","newDeck","removeCard","card","index","indexOf","splice","drawCard","draw","nCards","arguments","undefined","Array","from","_Deck","suits","ranks","getRank","getSuit","getScore","scoreTable","forEach","rank","idx","getCards","map","suit","concat","flat","Hand","_Hand","hand","some","test","Error","handRanks","sort","a","b","Set","size","join","royalFlush","straightFlush","flush","handCounts","reduce","acc","sortedRanks","Object","keys","Number","ca","cb","fourOfAKind","fullHouse","straight","threeOfAKind","twoPair","onePair","highCard","best","items","groupSize","results","combine","start","combination","push","pop","getCombinations","combo","current","compare","hand1","hand2","handOneRank","handTwoRank","handOneCardRank","handTwoCardRank","Game","myHand","numPlayers","_this2","simulationSettings","iterations","deck","communityCards","potSize","amountToCall","maxRaiseAmount","foldProbability","calculatedWinProbability","resetCalculations","setPotSize","setAmountToCall","setNumPlayers","addCommunityCard","drawCommunityCards","simulateOnce","deckCopy","community","myBestHand","every","opHand","opponentBestHand","simulate","wins","simulationsCount","t1","Date","now","expiration","milliseconds","t2","console","log","getExpectedReturnOnCall","winProbability","getIdealRaiseAmount","bestRaiseAmount","maxExpectedReturn","raiseAmount","expectedReturn","k","combinationProbability","pow","potAfterRaise","costToRaise","decideAction","expectedReturnOnCall","idealRaiseAmount","expectedReturnOnRaise","action","amount","sendMessage","type","data","self","postMessage","terminate","createMessageSender","addEventListener","event","simulationIterations","progressInterval","game","pct","round"],"sourceRoot":""}