(()=>{"use strict";let t=function(t){return t[t.highCard=0]="highCard",t[t.onePair=1]="onePair",t[t.twoPair=2]="twoPair",t[t.threeOfAKind=3]="threeOfAKind",t[t.straight=4]="straight",t[t.flush=5]="flush",t[t.fullHouse=6]="fullHouse",t[t.fourOfAKind=7]="fourOfAKind",t[t.straightFlush=8]="straightFlush",t[t.royalFlush=9]="royalFlush",t}({});function s(t){for(let s=t.length-1;s>0;s--){const e=Math.floor(Math.random()*(s+1));[t[s],t[e]]=[t[e],t[s]]}return t}var e,i;class a{constructor(){var t=this;this.reset=()=>this.cards=a.getShuffledCards(),this.cards=a.getShuffledCards(),this.clone=()=>{const t=new a;return t.cards=[...this.cards],t},this.removeCard=t=>{const s=this.cards.indexOf(t);s>-1&&this.cards.splice(s,1)},this.drawCard=()=>{const t=Math.floor(Math.random()*this.cards.length),s=this.cards[t];return this.cards.splice(t,1),s},this.draw=function(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return Array.from({length:s},(()=>t.drawCard()))},this.shuffle=()=>(s(this.cards),this)}}e=a,a.suits=["C","D","H","S"],a.ranks=["2","3","4","5","6","7","8","9","T","J","Q","K","A"],a.getRank=t=>t[0],a.getSuit=t=>t[1],a.getScore=(()=>{const t={};return e.ranks.forEach(((s,e)=>{t[s]=e+2})),s=>t[e.getRank(s)]})(),a.getCards=()=>e.suits.map((t=>e.ranks.map((s=>"".concat(s).concat(t))))).flat(),a.getShuffledCards=()=>s(e.getCards());class r{}i=r,r.rankToString=s=>{switch(s){case t.royalFlush:return"Royal Flush";case t.straightFlush:return"Straight Flush";case t.fourOfAKind:return"Four of a Kind";case t.fullHouse:return"Full House";case t.flush:return"Flush";case t.straight:return"Straight";case t.threeOfAKind:return"Three of a Kind";case t.twoPair:return"Two pair";case t.onePair:return"One pair";default:return"High card"}},r.rank=s=>{if(s.some((t=>void 0===t)))throw new Error("Missing cards in hand");const e=s.map(a.getScore).sort(((t,s)=>s-t));if(1===new Set(s.map(a.getSuit)).size)return"1413121110"===e.join("")?[t.royalFlush,e]:e[0]-e[4]===4?[t.straightFlush,e]:[t.flush,e];const i=e.reduce(((t,s)=>(t[s]=(t[s]||0)+1,t)),{}),r=Object.keys(i).map(Number).sort(((t,s)=>{const e=i[t],a=i[s];return e===a?s-t:a-e}));return 4===i[r[0]]?[t.fourOfAKind,r]:3===i[r[0]]&&2===i[r[1]]?[t.fullHouse,r]:e[0]-e[4]===4&&5===new Set(e).size?[t.straight,e]:3===i[r[0]]?[t.threeOfAKind,r]:2===i[r[0]]&&2===i[r[1]]?[t.twoPair,r]:2===i[r[0]]?[t.onePair,r]:[t.highCard,r]},r.best=t=>function(t,s){const e=[];return function i(a,r){if(r.length!==s)for(let s=a;s<t.length;s++)r.push(t[s]),i(s+1,r),r.pop();else e.push([...r])}(0,[]),e}(t,5).map((t=>[...i.rank(t),t])).reduce(((t,s)=>s[0]>t[0]||s[0]===t[0]&&s[1].join()>t[1].join()?s:t)),r.compare=(t,s)=>{const e=t[0],i=s[0];if(e!==i)return e-i;for(let a=0;a<t[1].length;a++){const e=t[1][a],i=s[1][a];if(e!==i)return e-i}return 0};class n{constructor(t,s){var e=this;let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{iterations:1e4};this.myHand=t,this.numPlayers=s,this.simulationSettings=i,this.deck=new a,this.communityCards=[],this.potSize=0,this.amountToCall=0,this.maxRaiseAmount=1e3,this.foldProbability=.2,this.calculatedWinProbability=void 0,this.resetCalculations=()=>{this.calculatedWinProbability=void 0},this.setPotSize=t=>this.potSize=t,this.setAmountToCall=t=>this.amountToCall=t,this.setNumPlayers=t=>(this.resetCalculations(),this.numPlayers=t),this.addCommunityCard=t=>{this.resetCalculations(),this.deck.removeCard(t),this.communityCards.push(t)},this.drawCommunityCards=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;e.resetCalculations(),e.communityCards.push(...e.deck.draw(t))},this.simulateOnce=()=>{const t=this.deck.clone().shuffle(),s=[...this.communityCards,...t.draw(5-this.communityCards.length)],e=r.best([...this.myHand,...s]);return Array.from({length:this.numPlayers},(()=>t.draw(2))).every((t=>{const i=r.best([...t,...s]);return r.compare(e,i)>=0}))},this.simulate=()=>{let t=0,s=0;const e=Date.now();if(this.simulationSettings.iterations){s=this.simulationSettings.iterations;for(let e=0;e<s;e++)this.simulateOnce()&&(t+=1)}else{const i=e+this.simulationSettings.milliseconds;for(;Date.now()<i;)s+=1,this.simulateOnce()&&(t+=1)}const i=Date.now();return console.log("Simulations: ".concat(s," (").concat(1e3*s/(i-e),"/s)")),t/s},this.getExpectedReturnOnCall=()=>this.winProbability*(this.potSize+this.amountToCall)-this.amountToCall,this.getIdealRaiseAmount=()=>{const t=this.winProbability;let s=0,e=this.getExpectedReturnOnCall();for(let i=this.amountToCall;i<=this.maxRaiseAmount;i++){let a=0;for(let s=0;s<=this.numPlayers;s++){const e=Math.pow(1-this.foldProbability,s)*Math.pow(this.foldProbability,this.numPlayers-s),r=this.potSize+i*(s+1),n=i;a+=e*(t*Math.pow(this.foldProbability,this.numPlayers-s)*r-n)}a>e&&(e=a,s=i)}return s},this.decideAction=()=>{const t=this.getExpectedReturnOnCall(),s=this.getIdealRaiseAmount(),e=this.getExpectedReturnOnCall()+(s>0?s:0);return t>0&&t>=e?{action:"call",amount:this.amountToCall}:e>t?{action:"raise",amount:s}:{action:"fold",amount:0}},t.forEach((t=>this.deck.removeCard(t))),console.log("New game:",this)}get winProbability(){return void 0===this.calculatedWinProbability?this.calculatedWinProbability=this.simulate():this.calculatedWinProbability}}const o=function(){function t(t,s){self.postMessage({type:t,data:s})}return t.terminate=()=>{self.postMessage("TERMINATE")},t}();self.addEventListener("message",(t=>{const{myHand:s,numPlayers:e,communityCards:i,potSize:a,amountToCall:r,simulationIterations:l,progressInterval:h}=t.data.data,u=Date.now(),c=new n(s,e,{iterations:l});c.setPotSize(a),c.setAmountToCall(r),i.forEach((t=>c.addCommunityCard(t)));let d=0;for(let n=0;n<l;n++)c.simulateOnce()&&(d+=1),n%h===0&&o("progress",{pct:n/l*100,winProbability:d/(n+1)});o("progress",{pct:100,winProbability:d/l});const m=Date.now();console.log("".concat(Math.round(1e3*l/(m-u))," sim/sec")),o.terminate()}))})();
//# sourceMappingURL=265.12fd0b2d.chunk.js.map